МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ






Звіт
з лабораторної роботи № 4 з дисципліни
Аналіз та рефакторинг коду
за темою «Програмна система для допомоги тваринам у притулках із використанням технологій IoT, веб та мобільних клієнтів» 





Виконала:                                                                 Перевірив:
ст. гр. ПЗПІ-23-5                        			ст. викладач кафедри ПІ
Бураковська Марія					Сокорчук Ігор Петрович







Харків 2025
1 ІСТОРІЯ ЗМІН
№ДатаВерсія звітуОпис змін та виправлень116.12.20250.1Створення структури звіту 



2 ЗАВДАННЯ
* Розробити будову програмного забезпечення ІоТ клієнта.
* Створити UML діаграму прецедентів для ІоТ клієнта.
* Розробити бізнес логіку (математину обробку повʼязаних із предметною областю даних) та функції налаштування ІоТ клієнта.
* Створити діаграму діяльності для ІоТ клієнта.
* Створити програмну реалізацію бізнес логіки та функцій налаштування ІоТ клієнта.
* Перевірити роботу ІоТ клієнта.


     3 ОПИС ВИКОНАНОЇ РОБОТИ
     IoT-клієнт розроблено як Python-додаток, що взаємодіє з серверною частиною лабораторної системи через HTTP API. Основна задача клієнта — періодично зчитувати дані з віртуальних сенсорів, проводити локальний аналіз на предмет аномалій та відправляти дані на сервер для подальшої обробки та зберігання.
   Архітектура клієнта включає наступні модулі:
*  sensor.py – емулятор сенсорів (температура та вологість). Забезпечує генерацію значень у межах реалістичних фізіологічних параметрів для тварин;
*  logic.py – бізнес-логіка клієнта, що виконує математичний аналіз даних сенсорів. Застосовується алгоритм статистичного контролю аномалій: розрахунок середнього, стандартного відхилення та перевірка, чи виходить поточне значення за межі допустимих коливань;
*  network.py – модуль для взаємодії з сервером. Формує JSON-повідомлення та відправляє його на серверний API;
*  main.py – головний цикл роботи клієнта. Організовує опитування сенсорів, накопичення історії останніх 10 вимірювань, локальний аналіз даних і відправку їх на сервер із заданим інтервалом.
     Весь код наведено в Додатку В, а тестування у Додатку Б.
     Бізнес-логіка реалізована у модулі logic.py та інтегрована в головному циклі клієнта (main.py). Основні інженерні рішення:
* аналіз аномалій: для кожного сенсора зберігаються останні 10 значень. Розраховуються середнє значення та стандартне відхилення. Поточне значення вважається аномальним, якщо воно виходить за межі ±2 стандартних відхилень від середнього;
* гнучкість: кількість збережених значень та поріг аномалії можна легко змінити через константи (SEND_INTERVAL, ANOMALY_THRESHOLD) у файлі config.py;
* масштабованість: структура словника history дозволяє легко додавати нові типи сенсорів, що відображається у списку SENSOR_TYPES.
     Це дозволяє клієнту не лише збирати дані, а й здійснювати попередню аналітику, зменшуючи навантаження на сервер.
     Налаштування зберігаються у config.py:
* SERVER_URL — адреса API сервера, куди надсилаються дані;
* ANIMAL_ID — унікальний ідентифікатор тварини, для якої проводиться моніторинг;
* SENSOR_TYPES — список типів сенсорів, що опитуються клієнтом (Temperature, Humidity);
* SEND_INTERVAL — інтервал у секундах між відправками даних;
* ANOMALY_THRESHOLD — коефіцієнт для визначення аномалії (використовується локально для аналізу).
     Таке налаштування дозволяє швидко змінювати параметри роботи клієнта без модифікації основного коду.
     Для візуалізації роботи IoT-клієнта створено UML-діаграми:
*  діаграма прецедентів (Use Case) — показує взаємодію користувача (або системи) з IoT-клієнтом: опитування сенсорів, відправка даних на сервер, локальний аналіз. (Див. Додаток Б, Рис. 1)
*  діаграма діяльності (Activity Diagram) — описує внутрішній цикл роботи клієнта: опитування сенсорів, оновлення історії, обчислення статистики, перевірка на аномалії та відправка даних на сервер. (Див. Додаток Б, Рис. 2)
     Ці діаграми допомагають зрозуміти логіку роботи IoT-клієнта та взаємодію з сервером без необхідності аналізувати код.


4 ВИСНОВКИ
     У ході виконання лабораторної роботи №4 було розроблено програмне забезпечення IoT-клієнта, яке реалізує бізнес-логіку обробки даних та функції налаштування відповідно до сучасної концепції IoT та SmartDevice систем.
     У межах роботи було спроєктовано архітектуру IoT-клієнта з чітким розподілом відповідальності між модулями, що забезпечує зрозумілість, масштабованість і зручність супроводу програмного коду. Бізнес-логіка клієнта реалізує локальну математичну обробку даних сенсорів шляхом розрахунку середнього значення та стандартного відхилення, що дозволяє виявляти аномальні показники ще на стороні клієнта та зменшувати навантаження на серверну частину системи.
     Реалізовані функції налаштування дозволяють змінювати основні параметри роботи IoT-клієнта (інтервал надсилання даних, типи сенсорів, поріг аномалії, адресу сервера) без втручання в основний програмний код, що підвищує гнучкість та адаптивність рішення.
Було створено UML-діаграму прецедентів та UML-діаграму діяльності, які наочно відображають функціональні можливості IoT-клієнта та логіку його роботи. Проведено тестування програмної реалізації, яке підтвердило коректність роботи бізнес-логіки та механізмів налаштування клієнта.


5 ВИКОРИСТАНІ ДЖЕРЕЛА
1. Gubbi J., Buyya R., Marusic S., Palaniswami M. Internet of Things (IoT): A vision, architectural elements, and future directions // Future Generation Computer Systems. – 2013.
2. Python Software Foundation. Python 3 Documentation - Офіційна документація мови Python. URL: https://docs.python.org/3/
3. Requests: HTTP for Humans. Official Documentation. URL: https://docs.python-requests.org/
4. IEEE. Standard for an Architectural Framework for the Internet of Things (IoT). – IEEE Std 2413-2019.

ДОДАТОК А
https://youtu.be/9NkTNREtcR4
0:52 - Загальна концепція IoT клієнта  
1:24 - Архітектура програмного забезпечення IoT клієнта  
2:28 - Бізнес-логіка IoT клієнта  
3:12 - Функції налаштування IoT клієнта  
3:51 - UML-діаграми IoT клієнт 
4:34 - Тестування

ДОДАТОК Б

Рисунок 1 - UML діаграма прецендентів IoT клієнта

Рисунок 2 - UML діаграма діяльності IoT клієнта

Рисунок 3 – Тестування IoT клієнта


ДОДАТОК В
	Файл config.py:
1. SERVER_URL = "http://localhost:3000/api/sensors"
2. ANIMAL_ID = 1
3. SENSOR_TYPES = ["Temperature", "Humidity"]
4. SEND_INTERVAL = 10  
5. ANOMALY_THRESHOLD = 2

	Файл logic.py:
1. import math
2. 
3. def analyze(values):
4.     mean = sum(values) / len(values)
5. 
6.     variance = sum((v - mean) ** 2 for v in values) / len(values)
7.     std_dev = math.sqrt(variance)
8. 
9.     current = values[-1]
10.     is_anomaly = abs(current - mean) > 2 * std_dev
11. 
12.     return {
13.         "current": current,
14.         "mean": round(mean, 2),
15.         "std_dev": round(std_dev, 2),
16.         "is_anomaly": is_anomaly
17.     }

	Файл main.py:
1. from sensor import read_temperature, read_humidity
2. from config import SENSOR_TYPES, SEND_INTERVAL
3. from logic import analyze
4. from network import send_data
5. import time
6. 
7. history = {sensor: [] for sensor in SENSOR_TYPES}
8. 
9. while True:
10.     for sensor_type in SENSOR_TYPES:
11. 
12.         if sensor_type == "Temperature":
13.             value = read_temperature()
14.         elif sensor_type == "Humidity":
15.             value = read_humidity()
16. 
17.         history[sensor_type].append(value)
18.         if len(history[sensor_type]) > 10:
19.             history[sensor_type].pop(0)
20. 
21.         result = analyze(history[sensor_type])
22.         print(f"{sensor_type} reading:", value, "Analysis:", result)
23. 
24.         send_data(sensor_type=sensor_type, value=value)
25. 
26.     time.sleep(SEND_INTERVAL)
27.

	Файл network.py:
1. import requests
2. from config import SERVER_URL, ANIMAL_ID
3. 
4. def send_data(sensor_type, value):
5.     payload = {
6.         "animal_id": ANIMAL_ID,
7.         "sensor_type": sensor_type,
8.         "value": value
9.     }
10. 
11.     try:
12.         response = requests.post(SERVER_URL, json=payload)
13.         print(f"SERVER RESPONSE ({sensor_type}):", response.status_code)
14.     except requests.exceptions.RequestException as e:
15.         print("Error sending data:", e)
16.

	Файл sensor.py:
1. import random
2. 
3. def read_temperature():
4.     return round(random.uniform(36.5, 38.5), 2)
5. 
6. def read_humidity():
7.     return round(random.uniform(40.0, 70.0), 2)
8.

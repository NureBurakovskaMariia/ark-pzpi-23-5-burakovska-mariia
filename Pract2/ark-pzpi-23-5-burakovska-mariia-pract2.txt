  МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ







Звіт
з практичної роботи № 2 з дисципліни
Аналіз та рефакторинг коду
   





Виконала:                                                                 Перевірив:
ст. гр. ПЗПІ-23-5                        			ст. викладач кафедри ПІ
Бураковська Марія					Сокорчук Ігор Петрович







Харків 2025
     Тема роботи: Методи рефакторингу програмного коду(Rename Method, Encapsulate Field, Replace Conditional with Polymorphism)
     Мета роботи: Навчитися основним методам рефакторингу коду на основі реальних прикладів з їхніх власних програмних проєктів. А також навчитися ідентифікувати проблеми в коді та використовувати відповідні методи рефакторингу для покращення його якості.
     Хід роботи
     Почнемо з короткого пояснення, що таке рефакторинг. Рефакторинг — це процес покращення структури існуючого коду без зміни його зовнішньої поведінки. Його головна мета — зробити код більш зрозумілим, гнучким і зручним у подальшій підтримці.
     З часом навіть добре написана програма може ускладнюватися: додаються нові функції, логіка росте, з’являються дублікати коду або неочевидні назви. Усе це ускладнює подальшу роботу з програмою. Саме в такі моменти нам і допомагає рефакторинг — він дає можливість очистити та впорядкувати код, не змінюючи того, як програма працює.
     Перша рекомендація — Rename Method. Метод Rename Method використовується тоді, коли назва методу не відображає чітко його призначення. Це здається дрібницею, але назви методів мають величезне значення, особливо у великих проєктах, де з кодом працює не одна людина.
Чому це важливо для мови програмування, наприклад, Java або C#:
У strongly typed мовах, як Java чи C#, велика частина взаємодії між класами відбувається саме через методи. Якщо метод названо невдало, інші розробники можуть неправильно зрозуміти його призначення і використати не за задумом.
     Наслідки недотримання правила:
	Плутанина в коді, зайві коментарі, довгі пошуки, де й як метод використовується. У гіршому випадку — логічні помилки.
Пояснення на прикладі:
Було, наприклад, так:
	public double calculate(Data data) { ... }
З назви не зрозуміло — що саме розраховується: площа, ціна, відстань?
Після рефакторингу ми перейменовуємо:
	public double calculateArea(Data data) { ... }
     І тепер усе очевидно — метод обчислює площу. 
     Переваги:
– Код став зрозумілішим без додаткових коментарів.
– Знижується ризик неправильного використання.
– Читач коду розуміє логіку ще до того, як відкрив сам метод.
     Таким чином, цей метод сприяє самодокументуванню коду — важливому принципу сучасного програмування.
     Наступний метод — Encapsulate Field, або «Інкапсуляція поля». Він застосовується, коли поля класу мають відкритий, тобто публічний доступ. У такому разі будь-який інший клас може змінити значення поля напряму.
Це порушує принцип інкапсуляції, який є однією з основ об’єктно-орієнтованого програмування.
     Чому це важливо:
     Інкапсуляція дозволяє захистити внутрішній стан об’єкта від неконтрольованих змін. Якщо змінювати поля напряму, код стає крихким — будь-який зовнішній клас може випадково зіпсувати логіку.
     Наслідки недотримання правила:
     Без інкапсуляції важко відстежити, хто саме і коли змінив значення. Це може призвести до непередбачуваних помилок.
     Пояснення на прикладі:
public class Rectangle {
    public double width;
    public double height;
}
     Після — ми робимо поля приватними і додаємо гетери/сетери:
public class Rectangle {
    private double width;
    private double height;

    public double getWidth() { return width; }
    public void setWidth(double width) { this.width = width; }
}
     Переваги:
– Ми контролюємо доступ до даних.
– Можна додати перевірку перед зміною значення.
– Код стає безпечнішим, стабільнішим і зручним для розширення.
     Це не просто «дрібне правило» — воно формує архітектурну дисципліну, без якої великі проєкти швидко втрачають керованість.
Третій метод — Replace Conditional with Polymorphism, або «Заміна умовної логіки поліморфізмом».
     Він використовується, коли в коді є великі блоки if-else або switch, які визначають поведінку об’єкта залежно від його типу.
     Чому це важливо:
     Такі конструкції порушують принцип відкритості/закритості (Open/Closed Principle): щоб додати нову поведінку, доводиться змінювати старий код. Це робить систему менш гнучкою.
     Приклад до рефакторингу:
if (shape.type == "circle") drawCircle();
else if (shape.type == "square") drawSquare();

     Ми створюємо базовий клас Shape і підкласи:
abstract class Shape { abstract void draw(); }
class Circle extends Shape {
    void draw() { /* малюємо коло */ }
}

class Square extends Shape {
    void draw() { /* малюємо квадрат */ }
}
     Тепер замість умов просто викликаємо shape.draw(). Код сам «знає», що робити, і ми можемо додавати нові типи без змін старого коду.
     Переваги:
– Код стає гнучким і масштабованим.
– Прибираються громіздкі умовні конструкції.
– Збільшується відповідність принципам ООП.
     Як це впливає на підтримку:
     У майбутньому, коли проєкт росте, додавання нових типів або поведінок не потребує переписування старої логіки. Це економить час і зменшує ризик помилок.
     Висновки:
     Отже, рефакторинг — це не просто технічна оптимізація, а інвестиція у якість програмного забезпечення.
     Методи Rename Method, Encapsulate Field і Replace Conditional with Polymorphism допомагають:
– зробити код більш зрозумілим;
– підвищити надійність і стабільність програми;
– спростити подальшу підтримку та розширення проєкту.
     Ці техніки показують, що навіть невеликі зміни у структурі можуть суттєво покращити зрозумілість і гнучкість системи.


ДОДАТОК А
Посилання на відео на YouTube: https://www.youtube.com/watch?v=eSPBvl5AugU
Таймкоди:
0:25 - Вступ
1:09 - Rename Method 
2:43 - Encapsulate Field
4:07 - Replace Conditional With Polimorphism
5:20 - Висновки
5:48 - Список використаних джерел

ДОДАТОК Б


Рисунок 1 – Титульний слайд


Рисунок 2 – Вступ



Рисунок 3 – Rename Method


Рисунок 4 – Приклад використання Rename Method



Рисунок 5 – Encapsulate Field


Рисунок 6 – Приклад використання Encapsulate Field



Рисунок 7 – Replace conditional with polymorphism


Рисунок 8 – Приклад використання Replace conditional with polymorphism



Рисунок 9 – Висновки


Рисунок 10 – Список використаних джерел
